<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projecting Judgements</title>
    <style>
        body {
            background-color: black;
        }
        canvas {
            position: absolute; /* Position canvas absolutely */
            top: 50px; /* Adjust this value based on your navigation bar height */
            left: 0;
        }
    </style>
</head>
<body>
    <script>
        function multiplyMatrix(mat1, mat2) {
            let result = [];
            for (let i = 0; i < mat1.length; i++) {
                let temp = [];
                let a = 0;
                while (a < mat2[0].length) {
                    let sum = 0;
                    for (let b = 0; b < mat1[0].length; b++) {
                        sum += mat1[i][b] * mat2[b][a];
                    }
                    temp.push(sum);
                    a++;
                }
                result.push(temp);
            }
            return result;
        };

        function vectorToMatrix(vec) {
            let result = [];
            for (let i = 0; i < vec.length; i++) {
                result.push([vec[i]]);
            }
            return result;
        }

        function matrixToVector(matrix) {
            return {
                x: matrix[0][0],
                y: matrix[1][0]
            }
        }

        const width = window.innerWidth;
        const height = window.innerHeight;

        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        canvas.width = width;
        canvas.height = height;

        const scale = 1;
        labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h','i'];
        keys = {'a': 'https://www.google.com', 'b': 'https://www.gmail.com', 'c': 'https://www.yahoo.com', 'd': 'https://www.facebook.com', 'e': 'https://www.reddit.com', 'f': 'https://www.twitter.com', 'g': 'https://www.osamakhalid.com', 'h': 'https://www.uiowa.edu','i':'https://www.github.com'};
        const points = [
            [-0.5, -0.5, -0.5],
            [0.5, -0.5, -0.5],
            [0.5, 0.5, -0.5],
            [-0.5, 0.5, -0.5],
            [-0.5, -0.5, 0.5],
            [0.5, -0.5, 0.5],
            [0.5, 0.5, 0.5],
            [-0.5, 0.5, 0.5],
            [-1.5, 1.5, 1.5],
        ];
        const projection_matrix = [
            [scale, 0, 0],
            [0, scale, 0]
        ];
        const ctx = canvas.getContext('2d', { alpha: false });
        function getRotationX(angle) {
            radians = angle * Math.PI / 180;
            return [
                [1, 0, 0],
                [0, Math.cos(radians), -Math.sin(radians)],
                [0, Math.sin(radians), Math.cos(radians)]
            ]
        }
        function getRotationY(angle) {
            radians = angle * Math.PI / 180;
            return [
                [Math.cos(radians), 0, Math.sin(radians)],
                [0, 1, 0],
                [-Math.sin(radians), 0, Math.cos(radians)]
            ]
        }
        let touchDistance = 0;

canvas.addEventListener('touchstart', (event) => {
    const touch1 = event.touches[0];
    const touch2 = event.touches[1];
    touchDistance = Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) +
        Math.pow(touch2.clientY - touch1.clientY, 2)
    );
});

canvas.addEventListener('touchmove', (event) => {
    if (event.touches.length === 2) {
        const touch1 = event.touches[0];
        const touch2 = event.touches[1];
        const newTouchDistance = Math.sqrt(
            Math.pow(touch2.clientX - touch1.clientX, 2) +
            Math.pow(touch2.clientY - touch1.clientY, 2)
        );

        const scaleFactor = newTouchDistance / touchDistance;
        touchDistance = newTouchDistance;

        // Adjust scale
        const newScale = scale * scaleFactor;

        // Ensure scale doesn't become too small or too large
        scale = Math.min(Math.max(newScale, 0.5), 2); // Example limits: 0.5 to 2
    }
});
        function getRotationZ(angle) {
            radians = angle * Math.PI / 180;
            return [
                [Math.cos(radians), -Math.sin(radians), 0],
                [Math.sin(radians), Math.cos(radians), 0],
                [0, 0, 1]
            ]
        }
        function calculateProjection() {
            let result = [];
            for (let i = 0; i < points.length; i++) {
                rotation_matrix = multiplyMatrix(getRotationX(anglex), getRotationY(angley), getRotationZ(anglez));
                let after_rotation = multiplyMatrix(rotation_matrix, vectorToMatrix(points[i]));
                projection = multiplyMatrix(projection_matrix, after_rotation);
                result.push(matrixToVector(projection));
            }
            return (result)
        }

        function calculateProjectionAndLabels() {
            let result = [];
            for (let i = 0; i < points.length; i++) {
                rotation_matrix = multiplyMatrix(getRotationX(anglex), getRotationY(angley), getRotationZ(anglez));
                let after_rotation = multiplyMatrix(rotation_matrix, vectorToMatrix(points[i]));
                projection = multiplyMatrix(projection_matrix, after_rotation);
                let projectedPoint = matrixToVector(projection);
                result.push({ point: projectedPoint, label: labels[i] });
            }
            return result;
        }

        function drawPointAndLabel(p, label) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.fillRect(p.x * 100 + centerX, p.y * 100 + centerY, 5, 5);
            if (isMouseOverPoint(p)) {
                ctx.font = '16px Arial'; // Set the font size and type
                ctx.fillText(label, p.x * 100 + (centerX+10), p.y * 100 + (centerY+10));
                console.log(label, p.x * 100 + (centerX+10), p.y * 100 + (centerY+10))
            }
        }

        canvas.addEventListener('click', (event) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    for (let i = 0; i < projection_data.length; i++) {
        const { point, label } = projection_data[i];
        const pointX = point.x * 100 + centerX;
        const pointY = point.y * 100 + centerY;
        
        if (
            mouseX >= pointX &&
            mouseX <= pointX + 25 &&
            mouseY >= pointY &&
            mouseY <= pointY + 25
        ) {
            const url = keys[label];
            if (url) {
                window.open(url, '_blank');
            }
            break;
        }
    }
});

        function isMouseOverPoint(point) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            return (
                mouseX >= (point.x * 100 + centerX) &&
                mouseX <= (point.x * 100 + centerX + 25) &&
                mouseY >= (point.y * 100 + centerY) &&
                mouseY <= (point.y * 100 + centerY + 25)
            );
        }

        ctx.fillStyle = 'white';
        anglex = 0;
        angley = 0;
        anglez = 0;

        let mouseX = 0;
        let mouseY = 0;

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;
        });

        function animationLoop() {
            let isMouseDown = false;
            let startX = 0;
            let startY = 0;

            canvas.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                startX = event.clientX;
                startY = event.clientY;
            });

            canvas.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaX = event.clientX - startX;
                    const deltaY = event.clientY - startY;
                    anglex = (anglex + deltaY * 0.1) % (360);  // Adjust the sensitivity as needed
                    startX = event.clientX;

                    // Correction made here
                    angley += (deltaX * 0.2) % (360); // Adjust the sensitivity as needed
                    startY = event.clientY;

                    //const deltaZ = deltaX * 0.3; // Adjust the sensitivity as needed
                    //anglez += deltaZ;
                }
            });

            canvas.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            ctx.clearRect(0, 0, width, height);

            //anglex += 1
            //angley += 1
            projection_data = calculateProjectionAndLabels();
            for (let i = 0; i < projection_data.length; i++) {
                const { point, label } = projection_data[i];
                drawPointAndLabel(point, label);
            }
            requestAnimationFrame(animationLoop);
        }
        animationLoop();
    </script>
</body>
</html>
